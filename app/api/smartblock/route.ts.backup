import { NextRequest, NextResponse } from 'next/server';

// Vercel ì„œë²„ë¦¬ìŠ¤ í•¨ìˆ˜ ì„¤ì •
// ë¬´ë£Œ í”Œëœ(Hobby) ì œí•œ: ìµœëŒ€ 10ì´ˆ ì‹¤í–‰ ì‹œê°„, 1024MB ë©”ëª¨ë¦¬
export const runtime = 'nodejs';
export const maxDuration = 10; // ë¬´ë£Œ í”Œëœ ìµœëŒ€ê°’

// Puppeteer ê´€ë ¨ íƒ€ì… ì •ì˜ (anyë¥¼ í”¼í•˜ê¸° ìœ„í•´)
type Puppeteer = typeof import('puppeteer');
type PuppeteerCore = typeof import('puppeteer-core');
type Chromium = typeof import('@sparticuz/chromium');

export async function POST(request: NextRequest) {
// 
  // í™˜ê²½ ë³€ìˆ˜ëŠ” í•¨ìˆ˜ ì‹œì‘ ì‹œ í•œ ë²ˆë§Œ ì½ìŠµë‹ˆë‹¤.
  const isVercel = process.env.VERCEL === '1' || process.env.VERCEL_ENV !== undefined;
  const isProduction = process.env.NODE_ENV === 'production';

  console.log('>>> í™˜ê²½ ì •ë³´:', {
    isVercel,
    isProduction,
    runtime: runtime, // 'nodejs'
  });

  let puppeteer: PuppeteerCore | Puppeteer | null = null;
  let chromium: Chromium | null = null;
  let importError: any = null;

  try {
    const { keyword } = await request.json();

    if (!keyword) {
      return NextResponse.json({ error: 'í‚¤ì›Œë“œê°€ í•„ìš”í•©ë‹ˆë‹¤.' }, { status: 400 });
    }

    // --- ë™ì  import ë° í™˜ê²½ ì„¤ì • ---
    if (isVercel) {
      // Vercel í™˜ê²½: puppeteer-core + @sparticuz/chromium ì‚¬ìš© (í•„ìˆ˜)
      console.log('>>> Vercel í™˜ê²½: puppeteer-core + @sparticuz/chromium ë¡œë“œ ì‹œë„');
      try {
        // Vercelì—ì„œ í•„ìš”í•œ ëª¨ë“ˆë§Œ ë¡œë“œ
        puppeteer = (await import('puppeteer-core')).default as unknown as PuppeteerCore;
        chromium = await import('@sparticuz/chromium');
        console.log('>>> Vercelìš© Puppeteer/Chromium ë¡œë“œ ì„±ê³µ');
      } catch (vercelError: any) {
        importError = vercelError;
        console.error('>>> Vercel í™˜ê²½ Puppeteer ë¡œë“œ ì‹¤íŒ¨ (ì¢…ì†ì„± ëˆ„ë½ ê°€ëŠ¥ì„±):', vercelError.message);
        // ì´ í™˜ê²½ì—ì„œëŠ” ì´ ì‹œë„ê°€ ì‹¤íŒ¨í•˜ë©´ ë³µêµ¬ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.
      }
    } else {
      // ë¡œì»¬ ê°œë°œ í™˜ê²½: ì¼ë°˜ puppeteer ì‚¬ìš©
      console.log('>>> ë¡œì»¬ í™˜ê²½: ì¼ë°˜ puppeteer ë¡œë“œ ì‹œë„');
      try {
        puppeteer = (await import('puppeteer')).default as unknown as Puppeteer;
        console.log('>>> ë¡œì»¬ìš© Puppeteer ë¡œë“œ ì„±ê³µ');
      } catch (localError: any) {
        importError = localError;
        console.error('>>> ë¡œì»¬ í™˜ê²½ Puppeteer ë¡œë“œ ì‹¤íŒ¨:', localError.message);
      }
    }

    // ëª¨ë“  import ì‹œë„ê°€ ì‹¤íŒ¨í•œ ê²½ìš° ì²˜ë¦¬
    if (!puppeteer) {
      console.error('>>> ëª¨ë“  Puppeteer import ì‹œë„ ì‹¤íŒ¨');
      return NextResponse.json({
        error: 'Puppeteerë¥¼ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ì¢…ì†ì„± í™•ì¸ í•„ìš”)',
        details: importError?.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜',
        isVercel,
        isProduction,
      }, { status: 500 });
    }
    // --- ë™ì  import ë° í™˜ê²½ ì„¤ì • ë ---

    console.log('>>> Puppeteer ë¡œë“œ ìµœì¢… ì„±ê³µ. í¬ë¡¤ë§ ì‹œì‘:', keyword);
    // ì‹¤ì œë¡œ Puppeteer ì‹¤í–‰ ì‹œë„
    const smartBlockData = await crawlNaverSearchWithPuppeteer(
      keyword,
      puppeteer,
      chromium,
      isVercel
    );

    return NextResponse.json({
      keyword,
      timestamp: new Date().toLocaleString(),
      smartBlocks: smartBlockData,
      totalBlocks: smartBlockData.length
    });
  } catch (error: any) {
    console.error('ìµœì¢… í¬ë¡¤ë§/ì„œë²„ ì˜¤ë¥˜:', error);

    const errorResponse: any = {
      error: 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. Puppeteer ì‹¤í–‰ ì˜¤ë¥˜ê°€ ì˜ì‹¬ë©ë‹ˆë‹¤.',
    };

    // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ìƒì„¸ ì •ë³´ ë°˜í™˜
    if (process.env.NODE_ENV === 'development' || process.env.VERCEL_ENV === 'development') {
      errorResponse.details = error?.message;
      errorResponse.stack = error?.stack;
      errorResponse.name = error?.name;
    }

    return NextResponse.json(errorResponse, { status: 500 });
  }
}

async function crawlNaverSearchWithPuppeteer(
  keyword: string,
  puppeteer: any, // puppeteer-core ë˜ëŠ” puppeteer
  chromium: any, // @sparticuz/chromium ë˜ëŠ” null
  isVercel: boolean
) {
  let browser: any;
  const url = `https://search.naver.com/search.naver?query=${encodeURIComponent(keyword)}`;

  try {
    // Vercel í™˜ê²½ì— ìµœì í™”ëœ ì‹¤í–‰ ì˜µì…˜ ì„¤ì • (ë¬´ë£Œ í”Œëœ ìµœì í™”)
    let launchOptions: any = {
      headless: true,
      timeout: isVercel ? 2500 : 60000, // ë¬´ë£Œ í”Œëœ: 2.5ì´ˆ íƒ€ì„ì•„ì›ƒ
    };

    if (isVercel && chromium) {
      console.log('>>> Vercel ë¬´ë£Œ í”Œëœ: ê·¹ë„ë¡œ ìµœì í™”ëœ ì„¤ì • ì ìš©');
      // @sparticuz/chromiumì—ì„œ ê¶Œì¥í•˜ëŠ” ì¸ì ì‚¬ìš©
      launchOptions.args = [...chromium.args];
      launchOptions.executablePath = await chromium.executablePath();
      launchOptions.headless = chromium.headless; 

      // ë©”ëª¨ë¦¬ ë° ì„±ëŠ¥ ìµœì í™” ì¸ì (ë¬´ë£Œ í”Œëœìš©)
      launchOptions.args.push(
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--single-process', // ë©”ëª¨ë¦¬ ì ˆì•½ (í•„ìˆ˜)
        '--no-zygote', // ë©”ëª¨ë¦¬ ì ˆì•½ (í•„ìˆ˜)
        '--disable-gpu',
        '--disable-software-rasterizer',
        '--disable-dev-shm-usage',
        '--disable-extensions',
        '--disable-background-networking',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-breakpad',
        '--disable-component-update',
        '--disable-default-apps',
        '--disable-domain-reliability',
        '--disable-features=TranslateUI',
        '--disable-hang-monitor',
        '--disable-ipc-flooding-protection',
        '--disable-notifications',
        '--disable-renderer-backgrounding',
        '--disable-sync',
        '--metrics-recording-only',
        '--mute-audio',
        '--no-default-browser-check',
        '--no-first-run',
        '--no-pings',
        '--use-mock-keychain',
        '--hide-scrollbars',
        '--ignore-certificate-errors',
        '--ignore-ssl-errors',
        '--ignore-certificate-errors-spki-list',
        '--window-size=1024,768', // ë” ì‘ì€ ì°½ í¬ê¸°ë¡œ ë©”ëª¨ë¦¬ ì ˆì•½
        '--disable-web-security',
        '--disable-features=IsolateOrigins,site-per-process',
      );

      console.log('>>> Chromium executablePath ì„¤ì • ì™„ë£Œ:', launchOptions.executablePath ? 'OK' : 'FAIL');
    } else {
      // ë¡œì»¬ í™˜ê²½ ë˜ëŠ” Chromiumì„ ë¡œë“œí•˜ì§€ ëª»í•œ ê²½ìš°
      launchOptions.args = [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
      ];
    }
    
    // Puppeteerë¥¼ í—¤ë“œë¦¬ìŠ¤ ëª¨ë“œë¡œ ì‹¤í–‰ (ë¬´ë£Œ í”Œëœ: ë¹ ë¥¸ ì‹¤í–‰)
    try {
      console.log('>>> ë¸Œë¼ìš°ì € ì‹¤í–‰ ì‹œì‘ (íƒ€ì„ì•„ì›ƒ: 2.5ì´ˆ)');
      const launchPromise = puppeteer.launch(launchOptions);
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('ë¸Œë¼ìš°ì € ì‹¤í–‰ íƒ€ì„ì•„ì›ƒ')), 2500)
      );
      browser = await Promise.race([launchPromise, timeoutPromise]) as any;
      console.log('>>> Puppeteer ë¸Œë¼ìš°ì € ì‹¤í–‰ ì„±ê³µ');
    } catch (launchError: any) {
      console.error('>>> Puppeteer ë¸Œë¼ìš°ì € ì‹¤í–‰ ì‹¤íŒ¨:', launchError);
      throw new Error(`Puppeteer ë¸Œë¼ìš°ì € ì‹¤í–‰ ì‹¤íŒ¨: ${launchError?.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
    } 

    const page = await browser.newPage();
    
    // User-Agent ì„¤ì •
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
    
    // í˜ì´ì§€ ì´ë™ (ë¬´ë£Œ í”Œëœ: ì´ˆê³ ì† ë¡œë”©)
    const pageTimeout = isVercel ? 3500 : 60000; // ë¬´ë£Œ í”Œëœ: 3.5ì´ˆë§Œ ëŒ€ê¸°
    console.log(`>>> ë„¤ì´ë²„ ê²€ìƒ‰ í˜ì´ì§€ ë¡œë“œ ì‹œë„: ${url} (íƒ€ì„ì•„ì›ƒ: ${pageTimeout}ms)`);
    await page.goto(url, { 
      waitUntil: 'domcontentloaded',
      timeout: pageTimeout
    });

    // --- ìŠ¤í¬ë¡¤ ë¡œì§ (ìµœì†Œí™”) ---
    // ë¬´ë£Œ í”Œëœ: ìµœì†Œ ìŠ¤í¬ë¡¤ë§Œ (ë¹ ë¥´ê²Œ)
    if (isVercel) {
      // ë¹ ë¥¸ ìŠ¤í¬ë¡¤ (ìŠ¤ë§ˆíŠ¸ë¸”ë¡ì€ ë³´í†µ ìƒë‹¨ì— ìˆìŒ)
      await page.evaluate('window.scrollTo(0, 300)'); // ì•½ê°„ë§Œ ìŠ¤í¬ë¡¤
      await new Promise(resolve => setTimeout(resolve, 400)); // ì§§ì€ ëŒ€ê¸°
    } else {
      // ë¡œì»¬: ê¸°ì¡´ ë¡œì§
      let previousHeight;
      let scrollCount = 0;
      const maxScrolls = 10;
      while (scrollCount < maxScrolls) {
        previousHeight = await page.evaluate('document.body.scrollHeight');
        await page.evaluate('window.scrollTo(0, document.body.scrollHeight)');
        await new Promise(resolve => setTimeout(resolve, 2000));
        let newHeight = await page.evaluate('document.body.scrollHeight');
        if (newHeight === previousHeight) break;
        scrollCount++;
      }
    }
    // --- ìŠ¤í¬ë¡¤ ë¡œì§ ì¢…ë£Œ ---

    // ìŠ¤ë§ˆíŠ¸ë¸”ë¡ ì»¨í…Œì´ë„ˆë¥¼ ì°¾ê¸° ìœ„í•œ ì…€ë ‰í„°
    const smartBlockSelectors = [
      'a.jyxwDwu8umzdhCQxX48l',
      '.fds-flicking-augmentation a',
    ];

    // ìŠ¤ë§ˆíŠ¸ë¸”ë¡ ëŒ€ê¸° (ë¬´ë£Œ í”Œëœ: ë§¤ìš° ì§§ì€ ëŒ€ê¸°)
    const selectorTimeout = isVercel ? 2000 : 15000; // ë¬´ë£Œ í”Œëœ: 2ì´ˆë§Œ ëŒ€ê¸°
    try {
        await Promise.any(smartBlockSelectors.map(selector => 
            page.waitForSelector(selector, { timeout: selectorTimeout })
        ));
    } catch (e) {
        console.log('>>> ìŠ¤ë§ˆíŠ¸ë¸”ë¡ ëŒ€ê¸° ì‹œê°„ ì´ˆê³¼. í˜„ì¬ DOMìœ¼ë¡œ ì¶”ì¶œ ì‹œë„.');
    }
    // ìµœì†Œ ëŒ€ê¸° (ë¬´ë£Œ í”Œëœ: 300ms)
    await new Promise(resolve => setTimeout(resolve, isVercel ? 300 : 2000));

    const smartBlocks = await page.evaluate(() => {
      const results: any[] = [];
      const extractedTitles = new Set<string>();
      const items: any[] = [];

      // ìŠ¤ë§ˆíŠ¸ë¸”ë¡ ë§í¬ ì°¾ê¸° (ì—¬ëŸ¬ ì…€ë ‰í„° ì‹œë„)
      const smartBlockLinks = document.querySelectorAll(
        'a.jyxwDwu8umzdhCQxX48l, ' +
        '.fds-flicking-augmentation a[href*="query="]'
      );

      smartBlockLinks.forEach((link: Element) => {
        // ê²€ìƒ‰ì–´ í…ìŠ¤íŠ¸ ì¶”ì¶œ (ì£¼ìš” í‚¤ì›Œë“œ)
        const textElement = link.querySelector('span.sds-comps-ellipsis-content');
        if (!textElement) return;

        // mark íƒœê·¸ë¥¼ ì œê±°í•˜ê³  ìˆœìˆ˜ í…ìŠ¤íŠ¸ë§Œ ì¶”ì¶œí•˜ëŠ” ë¡œì§ì€ ë³µì¡í•˜ë¯€ë¡œ,
        // í˜„ì¬ëŠ” í…ìŠ¤íŠ¸ë¥¼ í¬í•¨í•˜ëŠ” ê°€ì¥ ì•ˆì „í•œ ë°©ì‹ìœ¼ë¡œ ì¶”ì¶œí•©ë‹ˆë‹¤.
        const originalText = textElement.textContent?.trim() || '';
        let text = originalText.replace(/\s+/g, ' ').trim();

        if (!text || text.length < 1 || extractedTitles.has(text)) {
          return;
        }

        // íƒœê·¸ ì¶”ì¶œ (ë°•ìƒí›ˆë‹˜ì„ ìœ„í•œ, ìš”ì¦˜ ì¸ê¸° ë“±)
        let tag: string | undefined;
        let tagType: 'personal' | 'popular' | undefined;
        
        const badgeElement = link.querySelector('span.sds-comps-text-type-badge');
        if (badgeElement) {
          const badgeText = badgeElement.textContent?.trim() || '';
          tag = badgeText;
          if (badgeText.includes('ë‹˜ì„ ìœ„í•œ')) {
            tagType = 'personal';
          } else if (badgeText.includes('ì¸ê¸°')) {
            tagType = 'popular';
          }
        }

        items.push({
          title: text,
          tag: tag,
          tagType: tagType,
          icon: tagType === 'popular' ? 'ğŸ”¥' : tagType === 'personal' ? 'â­' : 'ğŸ’¡',
          description: `${text} ê´€ë ¨ ì •ë³´`,
        });

        extractedTitles.add(text);
      });

      if (items.length > 0) {
        results.push({
          id: 'smart_block_' + Date.now(),
          title: 'í•¨ê»˜ ë§ì´ ì°¾ëŠ”',
          icon: 'ğŸ’¡',
          type: 'topics',
          data: items
        });
      }

      return results;
    });

    console.log(`>>> ìµœì¢… ì¶”ì¶œëœ ìŠ¤ë§ˆíŠ¸ë¸”ë¡ ê·¸ë£¹ ê°œìˆ˜: ${smartBlocks.length}`);

    return smartBlocks;
    
  } catch (error: any) {
    // ì˜¤ë¥˜ë¥¼ ìƒìœ„ë¡œ ì „ë‹¬í•˜ì—¬ catch ë¸”ë¡ì—ì„œ ì²˜ë¦¬
    throw error;
  } finally {
    if (browser) {
      // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ë¸Œë¼ìš°ì €ë¥¼ ë°˜ë“œì‹œ ë‹«ìŠµë‹ˆë‹¤.
      await browser.close();
    }
  }
}

